## What

Starter project for React development using 

* MOBX for state management,
* Vite for bundling,
* Lingui for i18n,
* Vitest for unit testing, 
* Emotion for component styling,
* RXJS for streaming (currently not used),
* Storybook for component development (and, in future, visual regression testing), and
* ESLint and Dprint for linting.

Has an example app which has a toy implementation of how installers and the model-view-presenter pattern can be used within the context of a React app. Includes examples of tests and storybooks for components and presenters.

## Why

There are a few things that seem contrary to software development bast practices in modern React development. Specifically

* Hooks strongly encourages developers to put business logic and asynchronous behavior inside render functions as `use` functions are only accessible in that context
* The lack of an broadly accepted dependency injection solution for React leads to prop-drilling and interfaces on components that aren't as narrow as they could/should be and/or have hidden dependencies on what amounts to globals

## How

Based on my experiences at _an unnamed large company_ who had addressed these problems in the context of a large, complex application, I have attempted to translate some of those learnings to a generalized set of patterns using modern React features and open source libraries.

Specifically 
* Extracting business logic and asynchronous behavior into presenters and storing the state in models following a MVP patterns
* Using installers for dependency injection and initialization

### Installers

Installers are just functions that create (or sometimes enhance) things based on the parameters provided. An example of an installer could be

```
type Greeter = {
  greet: (name: string) => Promise<string>,
};

function install(env: 'test' | 'prod'): Greeter {
  switch (env) {
    case 'test':
      return new SimulatedGreeter();
    case 'prod':
      return new FancyAIGreeter();
    default:
      throw new UnreachableError(env);
  }
}
```

Most of our installers are going to return components, so we can turn Greet into this

```
function install(greeter: Greeter) {
  return function ({ name }: { name: string }) {
    const [greeting, setGreeting] = useState<string | undefined>();
    useEffect(async function () {
      const greeting = greeter.greet(name);
      setGreeting(greeting);
    }, [name]);
    if (greeting == null) {
      return (<div>Loading...</div>);
    }
    return (
      <span>{greeting}</span>
    );
  }
}
```

### Partial Completion

So now we don't have any hidden dependencies on `useGreeter`, but the component is arguably even less testable than if it were standalone. Let's split out the component

```
function Greet({ name, greeter: Greeter }: { name: string, greeter: Greeter }) {
  const [greeting, setGreeting] = useState<string | undefined>();
  useEffect(async function () {
    const greeting = greeter.greet(name);
    setGreeting(greeting);
  }, [name]);
  if (greeting == null) {
    return (<div>Loading...</div>);
  }
  return (
    <span>{greeting}</span>
  );
}

function install(greeter: Greeter) {
  return function({ name }: { name: string }) {
    return <Greet name={name} greeter={greeter}/>;
  };
}
```

Better, but because we will be doing this kind of thing a lot, there's a utility function to help with that

```
function Greet({ name, greeter: Greeter }: { name: string, greeter: Greeter }) {
  ...
}

function install(greeter: Greeter): ComponentType<{ name: string }> {
  return createPartialComponent(Greet, { greeter });
}
```

### MVP

OK, but what about extracting the business logic? All that asynchronous behavior doesn't look like it belongs in a view at all.

TBD

### When to use Hooks/Context and when to inject

TBD

## Getting started

```
npm install
```

### VSCode Extensions

* `ESLint` by `Microsoft`
* `Code Spell Checker` by `Street Side Software`
* `vscode-styled-components` by `Styled Components`
* `glslx-vscode` by `evanw`

### Running 

```
npm run dev
```

### Testing and support 

#### Running Unit Tests

```
npm run test
```

#### Storybook

```
npm run storybook
```

#### Linting

```
npm run lint
```

The linter is configured to be extremely opinionated. The guiding principal is enforcing correctness where possible (e.g. using `===`) and minimizing diffs in PRs for reviewers. In the cases where it's 50/50 (e.g. quotation style), it's just my personal preference.

### Caveats and pitfalls

* Lingui doesn't like annotations (suspect Babel configuration incompatibility). For this reason you cannot use MOBX annotations in your .tsx files and will need to fallback to the functional style of creating observable, computed, etc...
* In spite of claiming to use the Vite configuration, Storybook will not import CommonJS modules (such as those generated by Lingui). To get around this we inject a custom `require` implementation into our storybooks
* The custom design system and theming in `ui/components` is targeted toward game development (where an off the shelf solution, such as Material, would be of limited benefit). I personally think Emotion is a really great library, but pick whatever design system you think will work best for you. 

### Future work

* Some kind of solution for routing and dynamically loading chunks of the UI on demand would be nice for a more complex application.